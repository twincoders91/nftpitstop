{"ast":null,"code":"const baseUrl = \"https://eth-mainnet.g.alchemy.com/v2/aI_cBhmYAlW4vQpliiy2kfOUZCmtYC9m\"; //================================fetching Owner's NFT array using wallet address================================================================\n//===============================================================================================================================================\n\nconst getAddressNFTs = async owner => {\n  try {\n    if (owner) {\n      let data;\n      data = await fetch(`${baseUrl}/getNFTs?owner=${owner}`).then(data => data.json());\n      console.log(data);\n      return data;\n    }\n  } catch (e) {\n    console.log(\"error found\", e);\n  }\n}; //=============================fetching each individual NFT Meta Data using contract addresses - NFT.contract.address================================\n//===================================================================================================================================================\n\n\nconst getNFTsMetaData = async NFTs => {\n  const NFTsMetaData = await Promise.allSettled(NFTs.map(async NFT => {\n    const metadata = await fetch(`${baseUrl}/getNFTMetadata?contractAddress=${NFT.contract.address}&tokenId=${NFT.id.tokenId}`);\n    const metadataJSON = await metadata.json(); //conditional statement to make sure IMAGES are present in meta data. Otherwise use placeholder image\n\n    let imageUrl;\n\n    if (metadataJSON.media[0].gateway.length) {\n      imageUrl = metadataJSON.media[0].gateway;\n    } else {\n      imageUrl = \"https://via.placeholder.com/500\";\n    } //conditional statement to make CONTRACTMETADATA is present. Else return UNDEFINED\n\n\n    let totalSupply;\n\n    if (metadataJSON.contractMetadata) {\n      if (metadataJSON.contractMetadata.totalSupply) {\n        totalSupply = metadataJSON.contractMetadata.totalSupply;\n      } else {\n        totalSupply = \"Not Found\";\n      }\n    } //conditional statement to make CONTRACTMETADATA is present. Else return UNDEFINED\n\n\n    let title;\n\n    if (metadataJSON.contractMetadata) {\n      if (metadataJSON.contractMetadata.name) {\n        title = metadataJSON.contractMetadata.name;\n      } else {\n        title = \"Not Found\";\n      }\n    } //conditional statement to make CONTRACTMETADATA is present. Else return UNDEFINED\n\n\n    let tokenType;\n\n    if (metadataJSON.contractMetadata) {\n      if (metadataJSON.contractMetadata.tokenType) {\n        tokenType = metadataJSON.contractMetadata.tokenType;\n      } else {\n        tokenType = \"Not Found\";\n      }\n    } //================================finding the floor price using a separate API================================\n    //==============================and then setting it into getNFTsMetaData's return=============================\n    // const floorPriceData = await fetch(\n    //   `https://eth-mainnet.g.alchemy.com/nft/v2/aI_cBhmYAlW4vQpliiy2kfOUZCmtYC9m/getFloorPrice?contractAddress=${NFT.contract.address}`\n    // );\n    // const floorPriceDataJSON = await floorPriceData.json();\n    // let nftFloorPrice;\n    // if (floorPriceDataJSON.openSea.floorPrice) {\n    //   nftFloorPrice = floorPriceDataJSON.openSea.floorPrice;\n    // } else {\n    //   nftFloorPrice = floorPriceDataJSON.openSea.error;\n    // }\n    //=============================================================================================================================\n    //=============================================================================================================================\n\n\n    return {\n      id: NFT.id.tokenId,\n      contractAddress: NFT.contract.address,\n      image: imageUrl,\n      title: title,\n      description: metadataJSON.metadata.description,\n      attributes: metadataJSON.metadata.attributes,\n      supply: totalSupply,\n      tokenType: tokenType // floorPrice: nftFloorPrice,\n\n    };\n  }));\n  return NFTsMetaData;\n}; //========================Fecthing the data from the above 3 APIs to consolidate meta data and floor price================================\n//========================================================================================================================================\n\n\nconst fetchNFTs = async (owner, setCollectionSize, setLoading, setNFTsApp) => {\n  setLoading(true);\n\n  try {\n    const collectionSize = await getAddressNFTs(owner);\n    setCollectionSize(collectionSize.totalCount);\n    const data = await getAddressNFTs(owner);\n    console.log(data);\n\n    if (data.ownedNfts.length) {\n      //passing in the owner's array of NFTs to get individual Meta Data\n      const NFTs = await getNFTsMetaData(data.ownedNfts); //making sure that the metaData of NFTs fetched are fulfilled. Filter those our that arent fulfilled.\n\n      let fulfilledNFTs = NFTs.filter(NFT => NFT.status == \"fulfilled\");\n      setLoading(false);\n      setNFTsApp(fulfilledNFTs);\n      console.log(fulfilledNFTs);\n    } else {\n      setNFTsApp(null);\n    }\n  } catch (e) {\n    setLoading(false);\n  }\n};\n\nexport { fetchNFTs };","map":{"version":3,"names":["baseUrl","getAddressNFTs","owner","data","fetch","then","json","console","log","e","getNFTsMetaData","NFTs","NFTsMetaData","Promise","allSettled","map","NFT","metadata","contract","address","id","tokenId","metadataJSON","imageUrl","media","gateway","length","totalSupply","contractMetadata","title","name","tokenType","contractAddress","image","description","attributes","supply","fetchNFTs","setCollectionSize","setLoading","setNFTsApp","collectionSize","totalCount","ownedNfts","fulfilledNFTs","filter","status"],"sources":["/Users/ymw/Desktop/Batcave/Our GitHub/GitHub/nftpitstop/NFTPitStop-main/src/nftAPI/fetchAPIs.js"],"sourcesContent":["const baseUrl =\n  \"https://eth-mainnet.g.alchemy.com/v2/aI_cBhmYAlW4vQpliiy2kfOUZCmtYC9m\";\n\n//================================fetching Owner's NFT array using wallet address================================================================\n//===============================================================================================================================================\nconst getAddressNFTs = async (owner) => {\n  try {\n    if (owner) {\n      let data;\n\n      data = await fetch(`${baseUrl}/getNFTs?owner=${owner}`).then((data) =>\n        data.json()\n      );\n      console.log(data);\n      return data;\n    }\n  } catch (e) {\n    console.log(\"error found\", e);\n  }\n};\n\n//=============================fetching each individual NFT Meta Data using contract addresses - NFT.contract.address================================\n//===================================================================================================================================================\n\nconst getNFTsMetaData = async (NFTs) => {\n  const NFTsMetaData = await Promise.allSettled(\n    NFTs.map(async (NFT) => {\n      const metadata = await fetch(\n        `${baseUrl}/getNFTMetadata?contractAddress=${NFT.contract.address}&tokenId=${NFT.id.tokenId}`\n      );\n      const metadataJSON = await metadata.json();\n\n      //conditional statement to make sure IMAGES are present in meta data. Otherwise use placeholder image\n      let imageUrl;\n      if (metadataJSON.media[0].gateway.length) {\n        imageUrl = metadataJSON.media[0].gateway;\n      } else {\n        imageUrl = \"https://via.placeholder.com/500\";\n      }\n\n      //conditional statement to make CONTRACTMETADATA is present. Else return UNDEFINED\n      let totalSupply;\n      if (metadataJSON.contractMetadata) {\n        if (metadataJSON.contractMetadata.totalSupply) {\n          totalSupply = metadataJSON.contractMetadata.totalSupply;\n        } else {\n          totalSupply = \"Not Found\";\n        }\n      }\n\n      //conditional statement to make CONTRACTMETADATA is present. Else return UNDEFINED\n      let title;\n      if (metadataJSON.contractMetadata) {\n        if (metadataJSON.contractMetadata.name) {\n          title = metadataJSON.contractMetadata.name;\n        } else {\n          title = \"Not Found\";\n        }\n      }\n\n      //conditional statement to make CONTRACTMETADATA is present. Else return UNDEFINED\n      let tokenType;\n      if (metadataJSON.contractMetadata) {\n        if (metadataJSON.contractMetadata.tokenType) {\n          tokenType = metadataJSON.contractMetadata.tokenType;\n        } else {\n          tokenType = \"Not Found\";\n        }\n      }\n\n      //================================finding the floor price using a separate API================================\n      //==============================and then setting it into getNFTsMetaData's return=============================\n\n      // const floorPriceData = await fetch(\n      //   `https://eth-mainnet.g.alchemy.com/nft/v2/aI_cBhmYAlW4vQpliiy2kfOUZCmtYC9m/getFloorPrice?contractAddress=${NFT.contract.address}`\n      // );\n\n      // const floorPriceDataJSON = await floorPriceData.json();\n      // let nftFloorPrice;\n      // if (floorPriceDataJSON.openSea.floorPrice) {\n      //   nftFloorPrice = floorPriceDataJSON.openSea.floorPrice;\n      // } else {\n      //   nftFloorPrice = floorPriceDataJSON.openSea.error;\n      // }\n\n      //=============================================================================================================================\n      //=============================================================================================================================\n      return {\n        id: NFT.id.tokenId,\n        contractAddress: NFT.contract.address,\n        image: imageUrl,\n        title: title,\n        description: metadataJSON.metadata.description,\n        attributes: metadataJSON.metadata.attributes,\n        supply: totalSupply,\n        tokenType: tokenType,\n        // floorPrice: nftFloorPrice,\n      };\n    })\n  );\n\n  return NFTsMetaData;\n};\n\n//========================Fecthing the data from the above 3 APIs to consolidate meta data and floor price================================\n//========================================================================================================================================\n\nconst fetchNFTs = async (owner, setCollectionSize, setLoading, setNFTsApp) => {\n  setLoading(true);\n  try {\n    const collectionSize = await getAddressNFTs(owner);\n    setCollectionSize(collectionSize.totalCount);\n    const data = await getAddressNFTs(owner);\n    console.log(data);\n    if (data.ownedNfts.length) {\n      //passing in the owner's array of NFTs to get individual Meta Data\n      const NFTs = await getNFTsMetaData(data.ownedNfts);\n      //making sure that the metaData of NFTs fetched are fulfilled. Filter those our that arent fulfilled.\n      let fulfilledNFTs = NFTs.filter((NFT) => NFT.status == \"fulfilled\");\n      setLoading(false);\n      setNFTsApp(fulfilledNFTs);\n      console.log(fulfilledNFTs);\n    } else {\n      setNFTsApp(null);\n    }\n  } catch (e) {\n    setLoading(false);\n  }\n};\n\nexport { fetchNFTs };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}